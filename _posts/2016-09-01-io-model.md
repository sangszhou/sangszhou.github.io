---
layout: post
title:  "IO 模型和 Java IO"
date:   "2016-09-01 00:00:00"
categories: java
keywords: java, io
---

## 概念

阻塞和非阻塞:

> 就函数的实现而言, 数据在就绪之前是等待还是立刻返回

同步和异步:

> 一个 IO 是指文件从磁盘到内核缓冲区再到用户空间的过程。不同和异步的区别就在于数据
> 从内核缓冲区到用户空间这个过程是否需要用户程序等待

这里是从操作系统角度对同步异步的理解, 如果从 API 的角度来讲, 一个 API 是异步的说的
是这个 API 是否会等待数据的返回。按照 akka doc 的说法就是 "a method call is considered
as synchronous if the caller cannot make progress until the method returns with 
a value or throws an exception"

## IO 模型

### 同步阻塞

网络编程中, 服务器读取客户端的数据要调用 recvfrom。在默认情况下, 这个调用会一直阻塞
到数据接受完毕, 这就是一个同步阻塞的 IO

![](/images/posts/linux/blockSynchronousIO.png)

### 同步非阻塞

网络编程中, 把 SOCKET 设置为 NONBLOCK 即可, 此方式仅对网络编程有效, 对磁盘文件无效。

![](/images/posts/linux/SynchronousUnblockingIO.png)

### IO 多路复用

如果有很多网络传输, 创建多个 socket 每个 socket 负责一个连接有些浪费线程资源, 一个更好的
办法是由一个中控系统负责 handle 所有的连接和数据传输请求, 当有请求发生时, 通过后端, 这样
可以实现较少的线程和较高的吞吐量 (表达的不好)

![](/images/posts/linux/IOMultiplexing.png)

在 linux 系统中, 实现 IO 多路复用的函数有三个, 分别是 select, poll 和 epoll.
其中 select 和 poll 的原理基本相同: 

1. 注册监听的 fd (注册时最好用非阻塞的)
2. 每次调用都会检查这些 fd 的状态

相比于 select, poll 解决了单个进程可以打开文件描述符有数量限制这个问题。 poll 通过
一个 pollfd 数组向内核传递需要关注的事件, 避开了文件描述符的数量限制。

select 和 poll 的问题在于包含 fd 的数组被整体复制与内核和用户空间之间, 开销随着 fd 的
增多而线性增大, 而基于事件驱动的 epoll 解决了这个问题:

1. 基于事件驱动, 避免了每次都要把所有的 fd 都扫一遍
2. epoll_wait 只返回就绪的 fd
3. epoll 使用 nmap 内存映射技术避免了内存复制的开销
4. epoll 的 fd 数量是操作系统的最大文件句柄数目, 这个数目一般很大 (ulimit -a)

此外，对于IO复用还有一个水平触发和边缘触发的概念：

* 水平触发：当就绪的fd未被用户进程处理后，下一次查询依旧会返回，这是select和poll的触发方式。
* 边缘触发：无论就绪的fd是否被处理，下一次不再返回。理论上性能更高，但是实现相当复杂，并且任何意外的丢失事件都会造成请求处理错误。epoll默认使用水平触发，通过相应选项可以使用边缘触发。


### 信号驱动

![](/images/posts/linux/SignalDrivenIO.png)

* 开启套接字信号驱动 IO 功能
* 用户程序调用 sigaction 执行信号处理函数
* 数据就绪, 生成 sigio 信号, 通过信号回调通知应用程序读取数据

### 异步非阻塞

![](/images/posts/linux/AsynchronousUnblockingIO.png)

数据已经拷贝到用户空间后再通知程序

## Java 网络编程

### BIO 
典型的网络编程模型, 通常是我们实现一个服务端程序, 步骤如下:

* 主线程 accept 请求阻塞
* 请求到达, 创建新线程处理这个套接字, 完成对客户端的响应
* 主线程继续 accept 下一个请求

### NIO

NIO 的实现流程有点像 select:

* 创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式
* 创建Reactor线程，创建多路复用器(Selector)并启动线程
* 将ServerSocketChannel注册到Reactor线程的Selector上。监听accept事件
* Selector在线程run方法中无线循环轮询准备就绪的Key
* Selector监听到新的客户端接入，处理新的请求，完成tcp三次握手，建立物理连接
* 将新的客户端连接注册到Selector上，监听读操作。读取客户端发送的网络消息
* 客户端发送的数据就绪则读取客户端请求，进行处理

### AIO
Java7 引入 NIO2.0, 提供了异步文件通道和异步套接字通道的实现, 相当于 Linux 中的异步 IO

* 创建AsynchronousServerSocketChannel，绑定监听端口
* 调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler。包括上一步，都是非阻塞的
* 连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler。
* 数据就绪，触发负责处理数据的CompletionHandler的completed方法。继续做下一步处理即可。
* 写入操作类似，也需要传入CompletionHandler。

### Reactor 

**单线程模型**

这是最简单的单Reactor单线程模型。Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分派请求到处理器链中。 该模型
适用于处理器链中业务处理组件能快速完成的场景。不过，这种单线程模型不能充分利用多核资源，所以实际使用的不多

![](/images/posts/java/reactor_model_1.png)

**多线程模型**

该模型在处理器链部分采用了多线程（线程池），也是后端程序常用的模型

![](/images/posts/java/reactor_model_2.png)

**第三种模型**比起第二种模型，是将Reactor分成两部分，mainReactor负责监听server socket，accept新连接，并
将建立的socket分派给subReactor。subReactor负责多路分离已连接的socket，读写网 络数据，对业务处理功能，其扔给worker线程池完成。通常，subReactor个数上可与CPU个数等同

![](/images/posts/java/reactor_model_3.png)

说完 Reactor 模型的三种形式，那么Netty是哪种呢？其实，我还有一种Reactor模型的变种没说，那就是去掉线程池的第三种形式的变种，
这也 是Netty NIO的默认模式。在实现上，Netty中的Boss类充当mainReactor，NioWorker类充当subReactor（默认 NioWorker的个数是
Runtime.getRuntime().availableProcessors()）。在处理新来的请求 时，NioWorker读完已收到的数据到ChannelBuffer中，之
后触发ChannelPipeline中的ChannelHandler流。

Netty是事件驱动的，可以通过ChannelHandler链来控制执行流向。因为ChannelHandler链的执行过程是在 subReactor中同步的，
所以如果业务处理handler耗时长，将严重影响可支持的并发数。这种模型适合于像Memcache这样的应用场景，但对需要操作数据库或者和其他模块阻塞交互的系统就不是很合适。

Netty的可扩展性非常好，而像ChannelHandler线程池化的需要，可以通过在 ChannelPipeline 中添加 Netty 内置的 ChannelHandler 实现类 ExecutionHandler 实现，
对使用者来说只是 添加一行代码而已。对于ExecutionHandler需要的线程池模型，Netty提供了两种可 选：

1） MemoryAwareThreadPoolExecutor 可控制Executor中待处理任务的上限（超过上限时，后续进来的任务将被阻 塞），并可控制单个Channel待处理任务的上限；

2） OrderedMemoryAwareThreadPoolExecutor 是  MemoryAwareThreadPoolExecutor 的子类，它还可以保证同一Channel中处理的事件流的顺序性，这主要是控制事件在异步处
理模式下可能出现的错误的事件顺序，但它并不保证同一Channel中的事件都在一个线程中执行（通常也没必要）。
一般来说，OrderedMemoryAwareThreadPoolExecutor 是个很不错的选择，当然，如果有需要，也可以DIY一个。


### Netty 的线程模型

### Netty, Mina // @todo

### 参考资料
[也谈IO模型](http://www.rowkey.me/blog/2016/01/18/io-model/#%E5%89%8D%E8%A8%80)
