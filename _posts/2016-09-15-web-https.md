---
layout: post
title: Https 原理
categories: [web]
description: https
keywords: https, web
---

https就是给http带了一个安全套，即使别人拿到了信息，也不知道这个里面装的啥。客户端（包括browser、手机app等）
和服务器每次发http包的时候，都对这个包加个密，让第三者看到的只是加密后的乱码，到对端以后再解密

## 加密算法

**非对称加密算法:** RSA，DSA/DSS

**对称加密算法:** AES，RC4，3DES

**HASH算法:** MD5，SHA1，SHA256


公钥只能进行加密，而解密是只能用私钥进行解密的。显然，这样的安全性很高，但有个很严重的问题就是，非对称解密相当损耗CPU性能，
https网站cpu损耗差不多90%的性能损耗都在非对称秘钥的解密上。全部内容都用非对称加密交流性能大大下降。
<<<<<<< Updated upstream

而对称加密，就是加密和解密都是用的同一个秘钥，加密和解密都很快，在不知道秘钥的情况下，想要破解的难度也非常大，比非对称加密破解还要难。
但有个问题就是，如果用对称秘钥的话，在第一次握手协商秘钥的时候，很可能就已经被劫持，这时你的加密也就毫无安全性可言了。

=======

而对称加密，就是加密和解密都是用的同一个秘钥，加密和解密都很快，在不知道秘钥的情况下，想要破解的难度也非常大，比非对称加密破解还要难。
但有个问题就是，如果用对称秘钥的话，在第一次握手协商秘钥的时候，很可能就已经被劫持，这时你的加密也就毫无安全性可言了。

>>>>>>> Stashed changes
用非对称秘钥进行秘钥协商，客户端，把自己支持的对称加密方式，通过公钥加密以后发送到站点，如果此时被劫持，他劫持掉你发送的消息，
在没有私钥的情况下，是无法解密的，也就无法仿造站点骗取你的各种信息了。如果没有被劫持，正确发送到了站点，
站点解密以后，会得到你支持的对称加密方式，然后选择一种性能和安全性最高的对称加密方式，把对称秘钥和握手成功的消息加密，
发送给你，你客户端解密之后，就知道秘钥和加密方式，接下来就可以进行下一步握手了。



## 证书的验证

当TLS协议验证一个网站是否有效的时候，Server会给出一个X509的证书链。客户端收到这个证书链以后，对证书链进行验证，所做的工作如下：

> 1、用最底端（证书链第一个）的证书，去验证请求的主机和证书里的是否是一致

> 2、逐次验证证书链里每张证书的合法性，直到找到一张证书在系统中存在: 这一步又包含每张证书是否在不信任名单里、
> 检查签名算法、检查时间是否过期、检查证书的发布者和证书链的上一级是否匹配、证书链的签名检查


简单来说是验证两个问题:

1. 证书是否是信任的有效证书。所谓信任：浏览器内置了信任的根证书，就是看看web服务器的证书是不是这些信任根发的或者信任根的二级证书机构颁发的。
所谓有效，就是看看web服务器证书是否在有效期，是否被吊销了。

2. 对方是不是上述证书的合法持有者。简单来说证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一
种是用证书做个信封，看对方是否能解开。

3. 验证证书是否由上级签发
<<<<<<< Updated upstream

以上的所有验证，除了验证证书是否吊销需要和CA关联，其他都可以自己完成。验证证书是否吊销可以采用黑名单方式或者OCSP方式。
黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP是实
时连接CA去验证，优点是实时，缺点是效率不高。

OCSP是在线证书状态检查协议 (OCSP 保存世界上所有的证书?)

做 api-gateway 时, Java 生成的证书应该就没有认证者, 浏览器无法验证其合法性所以就报错, (命令行用什么, 跳过验证 -k?)

### 验证证书是否是上级CA签发的

=======

以上的所有验证，除了验证证书是否吊销需要和CA关联，其他都可以自己完成。验证证书是否吊销可以采用黑名单方式或者OCSP方式。
黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP是实
时连接CA去验证，优点是实时，缺点是效率不高。

OCSP是在线证书状态检查协议 (OCSP 保存世界上所有的证书?)

做 api-gateway 时, Java 生成的证书应该就没有认证者, 浏览器无法验证其合法性所以就报错, (命令行用什么, 跳过验证 -k?)

### 验证证书是否是上级CA签发的

>>>>>>> Stashed changes
CA 下发给网站的证书是分层的证书链，从根证书开始一层层知道网站证书。要验证某一层证书是否确实有上级 CA 发放需要验证附带
在改证书上由上级 CA 通过签名函数及私钥生成的数字签名。数字签名需要上级 CA 的公钥，这个公钥就明文保存在证书链
中的上层证书中。而根证书是自己给自己签名，也就是根证书的签名也是靠自己保存的公钥来解密的。这就解决了真实性问题，也就是能证明最底
层的网站证书确实是证书中表明的CA发放的。


## 交互过程

![https_hello](/images/posts/web/https_connect.png)

这实际上就是文章一开始，我说的要解决的两个大问题：

1、认证server端的靠谱性

2、交换加密算法和密钥

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
在这一步，客户端主要向服务器提供以下信息。

> （1） 支持的协议版本，比如TLS 1.0版。

>  （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。

>  （3） 支持的加密方法，比如RSA公钥加密。

>  （4） 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪
一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。


2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

服务器回应（SeverHello）

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

> （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。

> （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。

> （3） 确认使用的加密方法，比如RSA公钥加密。

> （4） 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。
比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。


3.获得网站证书之后浏览器要做以下工作：

> a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。

> c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

> （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。

> （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

> （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，
接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，dog250解释得很好：


"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。


4.网站接收浏览器发来的数据之后要做以下的操作：

a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。

b) 使用密码加密一段握手消息，发送给浏览器。

5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：

其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，
而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。
非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，
所以网站都会非常小心的保管自己的私钥，防止泄漏。

TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，
于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息，但是这些手段都可以被识别出来


## 攻防

### 中间人攻击

### MD5 with salt

为了加强MD5的安全性（本身是不可逆的），从而加入了新的算法部分即加盐值，加盐值是随机生成的一组字符串，可以包括随机的大小写字母、
数字、字符，位数可以根据要求而不一样，使用不同的加盐值产生的最终密文是不一样的。

加盐的实现过程通常是在需要散列的字段的特定位置增加特定的字符，打乱原始的字符串，使其生成的散列结果产生变化。比如，用户使用了一个密码： x7faqgjw

经过MD5散列后，可以得出结果： 455e0e5c2bc109deae749e7ce0cdd397

但是由于用户密码位数不足，短密码的散列结果很容易被彩虹表破解，因此，在用户的密码末尾添加特定字符串（黑色字体为加盐的字段）： x7faqgjw**abcdefghijklmnopqrstuvwxyz**

因此，加盐后的密码位数更长了，散列的结果也发生了变化：4a1690d5eb6c126ef68606dda68c2f79

以上就是加盐过程的简单描述，在实际使用过程中，还需要通过特定位数插入、倒序或多种方法对原始密码进行固定的加盐处理，使得散列的结果更加不容易
被破解或轻易得到原始密码，比如（绿色字体为加盐字符串）：x7afabqgcjw

## 资料

[ref1](http://www.2cto.com/Article/201607/523509.html)
