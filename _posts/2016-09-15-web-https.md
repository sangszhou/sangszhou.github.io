---
layout: post
title: Https 原理
categories: [web]
description: https
keywords: https, web
---

https就是给http带了一个安全套，即使别人拿到了信息，也不知道这个里面装的啥。客户端（包括browser、手机app等）
和服务器每次发http包的时候，都对这个包加个密，让第三者看到的只是加密后的乱码，到对端以后再解密

## 加密算法

**非对称加密算法:** RSA，DSA/DSS

**对称加密算法:** AES，RC4，3DES

**HASH算法:** MD5，SHA1，SHA256


公钥只能进行加密，而解密是只能用私钥进行解密的。显然，这样的安全性很高，但有个很严重的问题就是，非对称解密相当损耗CPU性能，
https网站cpu损耗差不多90%的性能损耗都在非对称秘钥的解密上。全部内容都用非对称加密交流性能大大下降。
<<<<<<< Updated upstream

而对称加密，就是加密和解密都是用的同一个秘钥，加密和解密都很快，在不知道秘钥的情况下，想要破解的难度也非常大，比非对称加密破解还要难。
但有个问题就是，如果用对称秘钥的话，在第一次握手协商秘钥的时候，很可能就已经被劫持，这时你的加密也就毫无安全性可言了。

=======

而对称加密，就是加密和解密都是用的同一个秘钥，加密和解密都很快，在不知道秘钥的情况下，想要破解的难度也非常大，比非对称加密破解还要难。
但有个问题就是，如果用对称秘钥的话，在第一次握手协商秘钥的时候，很可能就已经被劫持，这时你的加密也就毫无安全性可言了。

>>>>>>> Stashed changes
用非对称秘钥进行秘钥协商，客户端，把自己支持的对称加密方式，通过公钥加密以后发送到站点，如果此时被劫持，他劫持掉你发送的消息，
在没有私钥的情况下，是无法解密的，也就无法仿造站点骗取你的各种信息了。如果没有被劫持，正确发送到了站点，
站点解密以后，会得到你支持的对称加密方式，然后选择一种性能和安全性最高的对称加密方式，把对称秘钥和握手成功的消息加密，
发送给你，你客户端解密之后，就知道秘钥和加密方式，接下来就可以进行下一步握手了。



## 证书的验证

当TLS协议验证一个网站是否有效的时候，Server会给出一个X509的证书链。客户端收到这个证书链以后，对证书链进行验证，所做的工作如下：

> 1、用最底端（证书链第一个）的证书，去验证请求的主机和证书里的是否是一致

> 2、逐次验证证书链里每张证书的合法性，直到找到一张证书在系统中存在: 这一步又包含每张证书是否在不信任名单里、
> 检查签名算法、检查时间是否过期、检查证书的发布者和证书链的上一级是否匹配、证书链的签名检查


简单来说是验证两个问题:

1. 证书是否是信任的有效证书。所谓信任：浏览器内置了信任的根证书，就是看看web服务器的证书是不是这些信任根发的或者信任根的二级证书机构颁发的。
所谓有效，就是看看web服务器证书是否在有效期，是否被吊销了。

2. 对方是不是上述证书的合法持有者。简单来说证明对方是否持有证书的对应私钥。验证方法两种，一种是对方签个名，我用证书验证签名；另外一
种是用证书做个信封，看对方是否能解开。

3. 验证证书是否由上级签发
<<<<<<< Updated upstream

以上的所有验证，除了验证证书是否吊销需要和CA关联，其他都可以自己完成。验证证书是否吊销可以采用黑名单方式或者OCSP方式。
黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP是实
时连接CA去验证，优点是实时，缺点是效率不高。

OCSP是在线证书状态检查协议 (OCSP 保存世界上所有的证书?)

做 api-gateway 时, Java 生成的证书应该就没有认证者, 浏览器无法验证其合法性所以就报错, (命令行用什么, 跳过验证 -k?)

### 验证证书是否是上级CA签发的

=======

以上的所有验证，除了验证证书是否吊销需要和CA关联，其他都可以自己完成。验证证书是否吊销可以采用黑名单方式或者OCSP方式。
黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。OCSP是实
时连接CA去验证，优点是实时，缺点是效率不高。

OCSP是在线证书状态检查协议 (OCSP 保存世界上所有的证书?)

做 api-gateway 时, Java 生成的证书应该就没有认证者, 浏览器无法验证其合法性所以就报错, (命令行用什么, 跳过验证 -k?)

### 验证证书是否是上级CA签发的

>>>>>>> Stashed changes
CA 下发给网站的证书是分层的证书链，从根证书开始一层层知道网站证书。要验证某一层证书是否确实有上级 CA 发放需要验证附带
在改证书上由上级 CA 通过签名函数及私钥生成的数字签名。数字签名需要上级 CA 的公钥，这个公钥就明文保存在证书链
中的上层证书中。而根证书是自己给自己签名，也就是根证书的签名也是靠自己保存的公钥来解密的。这就解决了真实性问题，也就是能证明最底
层的网站证书确实是证书中表明的CA发放的。


## 交互过程

![https_hello](/images/posts/web/https_connect.png)

这实际上就是文章一开始，我说的要解决的两个大问题：

1、认证server端的靠谱性

2、交换加密算法和密钥

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
在这一步，客户端主要向服务器提供以下信息。

> （1） 支持的协议版本，比如TLS 1.0版。

>  （2） 一个客户端生成的随机数，稍后用于生成"对话密钥"。

>  （3） 支持的加密方法，比如RSA公钥加密。

>  （4） 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪
一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。


2.网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

服务器回应（SeverHello）

服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

> （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。

> （2） 一个服务器生成的随机数，稍后用于生成"对话密钥"。

> （3） 确认使用的加密方法，比如RSA公钥加密。

> （4） 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。
比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。


3.获得网站证书之后浏览器要做以下工作：

> a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。

> c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

> （1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。

> （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

> （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，
接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把"会话密钥"。

至于为什么一定要用三个随机数，来生成"会话密钥"，dog250解释得很好：


"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"

此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。


4.网站接收浏览器发来的数据之后要做以下的操作：

a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。

b) 使用密码加密一段握手消息，发送给浏览器。

5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：

其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，
而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。
非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，
所以网站都会非常小心的保管自己的私钥，防止泄漏。

TLS握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。正是由于HTTPS非常的安全，攻击者无法从中找到下手的地方，
于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息，但是这些手段都可以被识别出来


## 攻防

### 中间人攻击

### MD5 with salt

为了加强MD5的安全性（本身是不可逆的），从而加入了新的算法部分即加盐值，加盐值是随机生成的一组字符串，可以包括随机的大小写字母、
数字、字符，位数可以根据要求而不一样，使用不同的加盐值产生的最终密文是不一样的。

加盐的实现过程通常是在需要散列的字段的特定位置增加特定的字符，打乱原始的字符串，使其生成的散列结果产生变化。比如，用户使用了一个密码： x7faqgjw

经过MD5散列后，可以得出结果： 455e0e5c2bc109deae749e7ce0cdd397

但是由于用户密码位数不足，短密码的散列结果很容易被彩虹表破解，因此，在用户的密码末尾添加特定字符串（黑色字体为加盐的字段）： x7faqgjw**abcdefghijklmnopqrstuvwxyz**

因此，加盐后的密码位数更长了，散列的结果也发生了变化：4a1690d5eb6c126ef68606dda68c2f79

以上就是加盐过程的简单描述，在实际使用过程中，还需要通过特定位数插入、倒序或多种方法对原始密码进行固定的加盐处理，使得散列的结果更加不容易
被破解或轻易得到原始密码，比如（绿色字体为加盐字符串）：x7afabqgcjw

## 资料

## Session and cookie

cookie技术是客户端的解决方案（当然随着html5的出现，比cookie更为强劲和安全的技术出现了，但是鉴于html5的普及度不够，就不做本文讨论的内容了），
Cookie就是由**服务器发给客户端的特殊信息**，而这些信息以**文本文件**的方式存放在客户端，然后客户端每次向服务器发送请求的时
候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供
包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回
这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客
户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们
可以从： [系统盘]:\Documents and Settings\[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服
务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。
有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，
从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，
那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。

session技术则是服务端的解决方案，它是通过服务器来保持状态的。由于Session这个词汇包含的语义很多，因此需要在这里明确一下 
Session的含义。首先，我们通常都会把Session翻译成会话，因此我们可以把客户端浏览器与服务器之间一系列交互的动作称
为一个 Session。从这个语义出发，我们会提到Session持续的时间，会提到在Session过程中进行了什么操作等等；
其次，Session指的是服务器端为客户端所开辟的存储空间，在其中保存的信息就是用于保持状态。从这个语义出发，我
们则会提到往Session中存放什么内容，如何根据键值从 Session中获取匹配的内容等。要使用Session，第一步当
然是创建Session了。那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应
用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。
在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创
建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，
发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找
到相应的Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。

cookie和session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，上面
我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部
发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，
服务端的session也会不能正常使用（注意：有些资料说ASP解决这个问题，当浏览器的cookie被禁掉，服务端的session任然可以正常使用，
ASP我没试验过，但是对于网络上很多用php和jsp编写的网站，我发现禁掉cookie，网站的session都无法正常的访问）

实现包的路径是：org.apache.catalina.session，tomcat对外提供session调用的接口不在这个实现包里，
对外接口是在包javax.servlet.http下的HttpSession，而实现包里的StandardSession是tomcat提供的标准实现，
当然对外tomcat不希望用户直接操作StandardSession，而是提供了一个StandardSessionFacade类，tomcat容器里
具体操作session的组件是servlet，而servlet操作session是通过StandardSessionFacade进行的，这样就可以防
止程序员直接操作StandardSession所带来的安全问题。(StandardSessionFacade使用了设计模式里的Façade（外观）模式，
外观模式能让不同逻辑层的组件进行解耦)。

### 如何进行高效的session同步

讲到解决这些问题之前，我们首先要考虑下session如何存储才是高效，是存在内存、文件还是数据库了？
文件和数据库的存储方式都是将session的数据固化到硬盘上，操作硬盘的方式就是IO，IO操作的效率是远远低于操作内存的数据，
因此文件和数据库存储方式是不可取的，所以将session数据存储到内存是最佳的选择。因此最好的解决方案就是使用分布式缓存技术，
例如：memcached和redis，将session信息的存储独立出来也是解决session同步问题的方法

### 长连接与短连接

**短连接**

我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。
client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，
不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。
从上面的描述看，短连接一般只会在client/server间传递一次读写操作。

**长连接**

首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，
从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，
则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：

> 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。

> 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。

> 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。

> 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。

在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直
不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要
采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受
损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

TCP的keep alive是检查当前TCP连接是否活着；HTTP的Keep-alive是要让一个TCP连接活久点





[ref1](http://www.2cto.com/Article/201607/523509.html)
