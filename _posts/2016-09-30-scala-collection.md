---
layout: post
title: scala collection
categories: [scala]
keywords: scala, collection
---

## Closure

内部类引用外部局部变量

```scala
class ClosureDemo {
  def main(args: Array[String]): Unit = {
    val x = 1
    def method: Int => Int = y => y + x
  }
}

public final class play.ClosureDemo$$anonfun$method$1$1 extends scala.runtime.AbstractFunction1$mcII$sp 
    implements scala.Serializable {
  
  public static final long serialVersionUID;
  private final int x$1;
  public final int apply(int);
  public int apply$mcII$sp(int);
  public final java.lang.Object apply(java.lang.Object);
  public play.ClosureDemo$$anonfun$method$1$1(play.ClosureDemo, int);
}
```

从上面的代码可以看出, scala 也是在内部类中创建了成员变量。在查看内部类的字节码时, 有一点需要注意, method 对应的内部类有很多 $$ 符号,
使用 zsh 可能会对 class 造成转移, javap -c xx.class 会提示找不到类型, 解决方案是把 xx.class 改个名字, 把 $$ 去掉。

## Local variables referenced from a lambda expression must be final or effectively final

The fundamental difference between a field and a local variable is that the local variable is copied when JVM creates a 
lambda instance. On the other hand, fields can be changed freely, because the changes to them are propagated 
to the outside class instance as well (their scope is the whole outside class, as Boris pointed out below).

The easiest way of thinking about anonymous classes, closures and lambdas is from the variable scope perspective; 

imagine a copy constructor added for all local variables you pass to a closure.

> starting in Java SE 8, a local class can access local variables and parameters of the enclosing block 
> that are final or effectively final. A variable or parameter whose value is never changed after it is 
> initialized is effectively final

For example, suppose that the variable numberLength is not declared final, and you add the marked 
assignment statement in the PhoneNumber constructor:

```scala
PhoneNumber(String phoneNumber) {
    numberLength = 7;   // <== assignment to numberLength
    String currentNumber = phoneNumber.replaceAll(regularExpression, "");
    if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber;
    else formattedPhoneNumber = null;
}
```

Because of this assignment statement, the variable numberLength is not effectively final anymore. 
As a result, the Java compiler generates an error message similar to "local variables referenced from an 
inner class must be final or effectively final" where the inner class PhoneNumber tries to access the numberLength variable:

```java
    public void tst() {
        int st = 0;
        new Thread(() -> {
            System.out.println(st);
        }).start();
    }
```

在 inner class 内部没有修改 st 的值, 所以被称为 effective final, 如果在 Thread 中添加了了 st = 2, 对 st 的值发生了改变,
这个时候就不是 effective final 的了, 编译器就会报错

但是在 scala 里面, 在外部的值, 不会受到内部值的影响

```scala
  def main(args: Array[String]): Unit = {

    var x = 1

    def method: Int => Int = y => {
      x = 3
      x
    }
    println(x) // 1
    println(method(3)) // 3
  }
```

So when you use any field (let say private Integer i;)from the enclosing class which is not declared final and not effectively final it will still work as the compiler makes the trick on your behalf and insert "this" (this.i).

```java
private Integer i = 0;

public  void process(){
    Consumer<Integer> c = (i)-> System.out.println(++this.i);
    c.accept(i);
}
```

传递可变类型

```java
    public void tst() {
        int st = 0;
        Person self = new Person("a", "b");

        new Thread(() -> {
            self.name = "asj";
            System.out.println(self.name); // asj
        }).start();

        try {
            Thread.sleep(30);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(self.name); // asj
    }
```

When you create an instance of an anonymous inner class, any variables which are used within that class have their values copied in via the autogenerated constructor.

As the value has been copied into the instance of the anonymous inner class, it would look odd if the variable 
could be modified by the rest of the method - you could have code which appeared to be working with an out-of-date 
variable (because that's effectively what would be happening... you'd be working with a copy taken at a different time). 
Likewise if you could make changes within the anonymous inner class, developers might expect those changes to be 
visible within the body of the enclosing method.

Making the variable final removes all these possibilities - as the value can't be changed at all, you don't need to 
worry about whether such changes will be visible. The only ways to allow the method and the anonymous inner class 
see each other's changes is to use a mutable type of some description. This could be the enclosing class itself, 
an array, a mutable wrapper type... anything like that. Basically it's a bit like communicating between one 
method and another: changes made to the parameters of one method aren't seen by its caller, but changes made to 
the objects referred to by the parameters are seen.

For scalar values, once it has been assigned, the value of the final variable cannot change. For object values, the reference cannot change.

This allows the Java compiler to "capture" the value of the variable at run-time and store a copy as a field in the inner class.

Once the outer method has terminated and its stack frame has been removed, the original variable is gone but the inner class's private copy persists in the class's own memory.

### tail recursion

Functions like approximate, which call themselves as their last action, are called tail recursive

```scala
def approximate(guess: Double): Double =
    if (isGoodEnough(guess)) guess
    else approximate(improve(guess))
    
def approximateLoop(initialGuess: Double): Double = {
    var guess = initialGuess
    while (!isGoodEnough(guess))
      guess = improve(guess)
    guess
}
```

为什么下面的就不行

```scala
def boom(x: Int): Int =
    if (x == 0) 0
    else boom(x - 1) + 1
```

因为递归函数是往下走的, 这个逻辑, while 循环是可以描述的。

+1 意味着当递归函数返回的时候再做后续的处理, 而这个逻辑 while 描述不了

## Initialization-on-demand holder idiom

In software engineering, the Initialization on Demand Holder (design pattern) idiom is a lazy-loaded singleton. 
In all versions of Java, the idiom enables a safe, highly concurrent lazy initialization with good performance.

```java
public class Something {
    private Something() {}

    private static class LazyHolder {
        private static final Something INSTANCE = new Something();
    }

    public static Something getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

The implementation of the idiom relies on the initialization phase of execution within the 
Java Virtual Machine (JVM) as specified by the Java Language Specification (JLS).

When the class **Something** is loaded by the JVM, the class goes through initialization. Since the class does not 
have any static variables to initialize, the initialization completes trivially. The static class definition **LazyHolder** 
within it is **not initialized** until the JVM determines that LazyHolder must be executed. The static class LazyHolder is 
only executed when the static method **getInstance is invoked** on the class Something, and the first time this 
happens the JVM will load and initialize the LazyHolder class. The initialization of the LazyHolder class results 
in static variable INSTANCE being initialized by executing the (private) constructor for the outer class Something. 
Since the class initialization phase is guaranteed by the JLS to be serial, i.e., non-concurrent, no further 
synchronization is required in the static getInstance method during loading and initialization. And since the 
initialization phase writes the static variable INSTANCE in a serial operation, all subsequent concurrent invocations 
of the getInstance will return the same correctly initialized INSTANCE without incurring any additional synchronization overhead.

While the implementation is an efficient thread-safe "singleton" cache without synchronization overhead, 
and better performing than uncontended synchronization,[3] the idiom can only be used when the construction of 
Something can be guaranteed to not fail. In most JVM implementations, if construction of Something fails, subsequent 
attempts to initialize it from the same class-loader will result in a NoClassDefFoundError failure.

从上面可以看出, static 内部类不受外部类的制约, 且 private static class 的 private static 属性可以被外界所用到

[why the double check is broken](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)

## Dark size of scala

### 复杂的 collection 系统

![](/images/posts/scala/list-scala.png)

### 复杂的类型系统

1. Invariant/covariant/contravariant types (T, +T and -T)
2. Refined types (new Foo {...})
3. Structural types (x: {def y: Int})
3. Path dependant types (a.B)
4. Specialized types (@specialized)
5. Self types (this =>)
6. Projection types (A#B)
7. Existential types (M[_])
8. Type bounds (<:, >:)
9. Type constraints (=:=, <:< and <%<)
10. Type members (type T)
11. Type aliases (type T = Int)
12. Type classes ( (implicit ...) )
13. View bounds (<%)
14. Higher kinded types (* => *)
15. F-Bounded type polymorphism (M[T <: M[T]])


### confusing

```scala
def f(x: => Int) {}
Seq(1, 2) foreach f // failed to compile
f(1) // compiles successfully
def f(x: Int) {} // this f works with Seq
```


## List 是怎么实现的




```scala
val xs = List(1, 2, 3)
```

List 的子类有两个, 分别是 Nil Object 和 final class ::

```scala
case object Nil extends List[Nothing] {
    override def isEmpty = true
    def head: Nothing =
      throw new NoSuchElementException("head of empty list")
    def tail: List[Nothing] =
      throw new NoSuchElementException("tail of empty list")
}

final case class ::[T](hd: T, tl: List[T]) extends List[T] {
    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
    
    def length: Int = if (isEmpty) 0 else 1 + tail.length
    
    def drop(n: Int): List[T] =
        if (isEmpty) Nil
        else if (n <= 0) this
        else tail.drop(n - 1)
    
    // 这种实现简单, 但是有堆栈溢出的风险
    def map[U](f: T => U): List[U] =
        if (isEmpty) Nil
        else f(head) :: tail.map(f)
        
    // List 的 map 真正的实现方法, 使用循环来做
    final override def map[U](f: T => U): List[U] = {
        val b = new ListBuffer[U]
        var these = this
        while (!these.isEmpty) {
          b += f(these.head)
          these = these.tail
        }
        b.toList 
    }
        
    def :::[U >: T](prefix: List[U]): List[U] =
        if (prefix.isEmpty) this
        else prefix.head :: prefix.tail ::: this
}
```

mutable 数据结构的用处一般是初始化数据

List 的每个元素加一时

```scala
def incAll(xs: List[Int]): List[Int] = xs match {
    case List() => List()
    case x :: xs1 => x + 1 :: incAll(xs1)
}

// 更好的写法
val buf = new ListBuffer[Int]
  for (x <- xs) buf += x + 1
  buf.toList


```

## Vector 的实现

Scala的Vector实现为一组嵌套数组，在分割和连接时非常有效率。适用于大部分通用算法，因为它有高效的下标计算能力，以及能够在使用像+:和++方法时共享大部分内部结构的能力。

Vector采用分支系数为32的树状数据结构，分支因子是每个父节点允许拥有的最大子节点的数目。其随机访问（搜索或修改）复杂度是log_32(N)，使用32位整数下标时在JVM上是个效率不错的小常量，即使对很大的N来说都近似一个常量。

Vector是个由元素的下标组成的前缀树（trie），前缀树是给定路径上的所有子节点功用某种形式的公共键值。我们可以根据任何下标的二进制形式得到查找路径，实现高效的元素查找。

### Vector复制过程中的结构共享原理

在实际应用中，为了保持变量的不可变性，对有用的集合进行复制通常是必要的。假设有一个包含100 000个元素的Vector，需要得到一个副本，并替换掉原Vector的第8个元素，此时如果构造一个全新的100 000个元素的Vector将会是极其低效的。

为了兼顾高效和不可变性，可以通过共享原始Vector中的不变部分，而以某种方式表示变化部分，那么就可以高效地“创建”新Vector了。这种思想称之为结构共享。

如果其他线程中的代码正在对原始Vector做其他不同的操作，对原始的Vector的复制不会影响该操作，因为原Vector没有被修改。这样，只要对旧版本有一个或多个引用，就可以创建一个Vector的“历史”版本。直到对旧版本的引用消失为止，旧版本才会被垃圾回收。

![](/images/posts/scala/ori_trie_tree_vector.jpg)

现在假设要在2和3之间插入2.5，要创建一个新的副本，我们并不需要修改原来的树结构，而是创建新树

值得注意的是，原来的树（#1）仍然存在，但我们又创建了新的根（#2）和新的节点。创建新的树共享重用了原来的大部分节点，这样有助于降低修改集合的开销。

![](/images/posts/scala/new_trie_tree.jpg)

Scala的序列类型中Vector和List数据结构都是很常用的，Vector的所有操作都是O(1)（常数时间），而List对于那些需要访问头部以为元素的操作都需要O(n)操作，所以只在频繁执行头尾分解的情况下，推荐使用List。


[link1](http://www.jianshu.com/p/6b7792cfbeee)
[link2](http://stackoverflow.com/questions/20612729/how-does-scalas-vector-work)

### Blocking in actor

if using same dispatcher or node has only one CPU, it could lead to dead lock

### when using mutable and immutable

internal state change

Immutable objects do indeed make life simpler in many cases. They are especially applicable for value types, where objects don't have an identity so they can be easily replaced. And they can make concurrent programming way safer and cleaner (most of the notoriously hard to find concurrency bugs are ultimately caused by mutable state shared between threads). However, for large and/or complex objects, creating a new copy of the object for every single change can be very costly and/or tedious. And for objects with a distinct identity, changing an existing objects is much more simple and intuitive than creating a new, modified copy of it.

Think about a game character. In games, speed is top priority, so representing your game characters with mutable objects will most likely make your game run significantly faster than an alternative implementation where a new copy of the game character is spawned for every little change.

Moreover, our perception of the real world is inevitably based on mutable objects. When you fill up your car with fuel at the gas station, you perceive it as the same object all along (i.e. its identity is maintained while its state is changing) - not as if the old car with an empty tank got replaced with consecutive new car instances having their tank gradually more and more full. So whenever we are modeling some real-world domain in a program, it is usually more straightforward and easier to implement the domain model using mutable objects to represent real-world entities.

举个例子, 哪些 collection 看起来是 mutable 的, 但是用 immutable 实现也没问题

cache 使用 mutable 的 map

游戏人物 level 是 mutable 的, 但是 id 是 immutable 的



## 函数作为一等公民体现在哪里

1. 可传递, 赋值
2. 高阶
3. 嵌套函数和匿名函数
4. 闭包
5. 偏应用 (partial function)

Functor 是定义了 map 的容器类型

by name 只能出现在函数参数中, => R 类型只能出现在函数参数中, 表示 by name parameter 

```scala
def foo(f: () => String)
    println("111")
    println(f() + "OK")

foo( { println("AAA"; () => "AAA"} )
```

f 是函数, 而给的参数是表达式, 所以应该是值吧

结果是 AAA 111 AAAOK

```scala
def bar(f: => String)
    println("111")
    println(f + "OK")

bar( {println("AAA"); "AAA"} )
```

传名吧, 结果是 111 AAA, AAAOK

### mis

def foo() = xxx 在调用时可以省略 f 后面的 ()

但定义时如果不加小括号, def foo = xxx 则调用时加 () 要注意, foo() 被翻译成 foo.apply()

### 闭包 2

代码块 + 上下文, The binding of referencing environment

```scala
def a(i: Int, f: => Unit): Unit = {
    def b() { println(i) }
    if(i > 1) f else a(2, b)
}

a(1, {}) // 1
```

看来是早绑定