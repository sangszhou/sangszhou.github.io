---
layout: post
title: Block chain
categories: [distributed]
description: block chain
keywords: blockchain
---

## Block chain 区块链

区块链由比特币火起来，如今比特币已经超过 5000 人民币一枚了，区块链也被应用到了各个领域。虽然这是一篇对区块链的文章，但是我目前对区块链的理解还是不够，只是对这两天区块链学习的总结。

区块链技术的目的是，在一个没有中心的 P2P 系统中，任意两个节点（人）能够完成交易，这个交易最终会被整个集群认可。这个是最终一致性的分布式系统，
根据 CAP 原理，它放弃了 C 则能够获得 A 和 P, 即可用性和分区容错性。从下面的分析中可以看出，CAP holds on block chain.

从学习的过程中，我一直在想，block chain 真的有别人讲起来的这么神奇么，假如有这么神奇的话，那么 Paxos, Raft 岂不是很尴尬？这两天学习的结论是，它是个很奇妙的技术，但是距离真正的使用还有很长的距离。它的缺点有 （1）不适合用于高交易量的系统，目前的每秒交易量是个位数。达到几万的级别应该会很难 （2）不适合低延迟交易，目前每个区块的打包时间在 10min 左右，打包一次并不能确保消息真的被系统所接受，目前 6 个更新的 block chain 出现后，才能确保数据真的有效，一次交易等待 1 小时，这个一般人还真等不起。这两个问题是在低频度的交易下已经暴露出的问题，等到交易的频度高起来后，可能出现的问题就更多了

下面讲解我对 block chain 的理解

### P2P system with only two users

1: 先假设有一个最简单的 P2P 系统，只有两个人 alice and bob. Alice 向 box 转了一笔账，这里有一个问题，box 收到钱后怎么知道是 alice 转的？单纯一个 From: alice 是不够的，因为这可以伪造，这个问题的解决方法很简单，账单上只需要加上 alice 的签名即可，alice 用私钥对账单进行签名，bob 拿着 alice 的公钥，就能确认这个账单是从 alice 发出的，并能解析出账单的内容

2: 钱从哪里来？系统中出现了第一张账单，但是与其说是账单，这更像是一个欠条，但是一个不可信的 P2P 系统是不允许欠条出现的。在区块链系统中，有一个创世块，创世块提供第一笔资金，这里可以简单的假设，alice 拥有创世块，所以她有第一笔钱。后面还会说到其他得到钱的方式

3: box 怎么知道 alice 有钱呢？每个账单上都会有钱的来源，账单会标注别人发给他的钱的所有账单的引用（账单号），bob 会验证账单的有效性，验证的过程就是检查所有的一直到初始块的账单。当一个新的用户安装客户端时，可能就需要验证世界上所有发生过的交易，听起来好像是一笔很大的工作量。感觉这种方式并不 scale

### P2P system with only three users

1: 当第三个人 chris 加入到系统来了，这时候 P2P 系统就变得复杂很多了，第一个问题就是如何识别 double spending. double spending 是说，alice 转账给 bob 和 chris, 但是钱的来源是相同的。因为是一个 P2P 系统，bob 和 chris 并不能问系统中的所有节点，因为这个系统是全球，这是一个很大的系统，另一个原因是 P2P 系统中的节点总是会加入或者离开，他并不是稳定的，也不知道 majority of P2P system. 那该怎么办呢？block chain 规定，每个节点在作出和收到一个交易时，会把这次交易的信息扩散到集群中的其他节点，最终这次交易会被集群中的所有节点所知晓，集群中有些节点会对这次交易进行验证，验证成功后会对结果进行存储和转发。

2: 紧接着第一条，如果某些节点同流合污，把虚假的信息发送到集群，该怎么办呢？因为存储和转发过程太过简单，代价太低，block chain 本身无法限制节点做坏事。block chain 是这么做的，如果某个节点要把某个或某些交易转发给其他节点，让其他节点认可，他除了转发交易信息本身外，还要再提供一个信息，nonce，其中 nonce + transactionId -> hash(_) -> ^0{n}。也就说说，节点要求出一个 nonce, 这个 nonce 加上 transaction id 后取 hash 的值，前 n 个数都是 0. 这就好像是说，你要投票？可以，先做道数学题。这个数学题倒不是难，只是做出来要花很长时间，假如某些节点一意孤行，宁愿花很长时间，也要把一个错误的结果发出去，蒙蔽他人，这个时候看整个系统作何反应，假设整个系统只有他一个人验证转发，那么他成功了的蒙蔽了所有的人，就好像是他伪造了一个 alice 到 box 的交易，这个交易并不存在，某一天，alice 说我怎么少了些钱，这样系统就被这个节点给毁了。假如还有一个人，这个人也验证并转发了这条交易信息，这个人无论是好人还是骗子，都会出现不一致的现象，因为这个骗子可能验证的是另一个假信息。假如有个好人验证了两条交易信息，那么两条交易信息的会取代一条，骗子花费的心血白费了。这也是 proof of work 的过程。只有当系统中骗子的计算力大于集群的一半时，系统才会不可靠。并且，这些骗子必须是同一阵营的，所有骗子产生相同的虚假信息。而好人，因为是诚实的，所以产生的消息天生是一致的。

3: 为什么有些节点愿意劳动，愿意验证信息。因为他们有奖赏，目前每次验证会得到 12.5 个比特币的收入，所以他们愿意花时间搞，这也是挖矿做的事，找到那个 nonce. 此外，比特币做了一个优化，不会对每个消息都单独验证，而是会把消息 group 起来，批量处理，降低每条消息的平均工作量，这样矿工有更多的利润空间，一般每 10 分钟 batch 一次，batch 出的一个东西就叫做 block. 每个 block  会有指向前一个 block ，这是为了让所有的节点都拥有相同的 block chain。

4: 在一个 block 出现后，用户的交易就算完成了，但是会出现冲突，即别的机器也做了一个 block, 接收的节点看到这两个 block 后不知道该选哪一个，解决冲突的办法是，让节点总是接收更长的那个。假如一个节点发现一个更长的，且与自己冲突的 block chain, 那么他会放弃自己的 block 转而接收更长的那一个，那么被抛弃的 block 上的交易该怎么办？呃，他们也被抛弃了。block never final. 不过 block 越长，以前的 block 被抛弃的概率越低，每个 block 大约 10 分钟，1小时后，基本上可以认为不会发生变化了

### 其他不理解的地方

1: 如果中国境内的机器和外国的分开了，假设分开了长达一天，那么中国境内的所有交易不就全部作废了么？

2: 如果参与比特币交易的人变得多了起来，全球各处每秒几万次交易，岂不是会有很多的冲突？ 1 小时后基本不变的准则岂不是要发生变化？

3: 假如某山寨币的参与用户比较少，那么计算 nonce 的标准就会比较低，参与的人多， nonce 的标准就比较高



