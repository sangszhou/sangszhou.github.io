---
layout: post
title: Paxos 1
categories: [distributed]
description: dis
keywords: paxos summary
---

## Paxos

Paxos is a family of protocols for solving consensus in a network of unreliable processors. 
Consensus is the process of agreeing on one result among a group of participants. 
This problem becomes difficult when the participants or their communication medium may experience failures.

###  假设

1. Processors operate at arbitrary speed
2. Processors may experience failure
3. Processors with stable storage may re-join the protocol after failure
4. Procesors do not collude, lie, or otherwise attempt to subvert the protocol.

1. Processors can send messages to another processor
2. Messages are sent asynchronously and may take arbitrarily long to deliver
3. Messages may be lost, reordered, or duplicated.
4. Messages are delivered without corruption.

简单来说，就是消息可能丢失，乱序，重复，延迟。进程可能会 crash, 延迟，或者 crash 之后重新加入到集群中。

### Roles

Acceptor(Voters):

The acceptor act as the fault-tolerant memory of the protocol. Acceptors are collected into groups called quorums. Any message sent to an acceptor must be sent to a quorum of acceptors.

Learner:

Learner act as the replication factor for the protocol. Once a client request has been agreed on by the acceptors, the learner may take action(execute the request and send a response to the client). To improve availability of processing, additional learner can be added.

Proposer:

A proposer advocates a client request, attempting to convince the acceptors to aggree on it, and acting as a coordinator to move the protocol forward when conflicts occur.

Paxos requires a distinguished proposer(called leader) to make progress. Many processes may believe they are leaders, but the protocol guarantees progress if one of them is eventually chosen. If two processes believe they are leaders, they may stall the protocol by continuously proposing conflicting updates. However, the safety properties are still preserved in that case.

Proposal number & aggreed value:

@todo

Non-trivality: only proposed values can be learned.

Safety: two different learners cannot learn different values.



## Basic Paxos

Each instance of basic paxos protocol on a single output value. The protocol proceeds over several rounds. A successfull round has two phase. A propose should not initate Paxos if it cannot communicate with at least a quorum of acceptors:

**Phase 1a: Prepare**

A proposer creates a proposal identified with a number N. This number must be greater than any previous proposal number used by this Proposer. Then it sends a Prepare message containing this proposal to Quorum of acceptors. The proposer decides who is in the Quorum.

从后面 multi-paxos 角度看 basic paxos, proposer number 变成了 sequence number


**Phase 1b: Promise**

If the proposal's number N is higher than any previous number received from any proposer by the acceptor, then the acceptor must return a promise to ignore all future proposals having a number less than N. If the acceptor accepted a proposal at some point in the past, it must include the previous proposal number and previous value in its response to the proposal.

otherwise, the acceptor can ignore the received proposal. It does not have to answer in this case for paxos to work. However, for the sake of optimization, sending a denial reponse would tell the proposal that it can stop its attempt to create consensus with proposal N.

**Phase 2a: Accept request**

If a Proposer receives enough promises from a Quorum of Acceptors, it needs to set a value to its proposal. If any Acceptors had previously accepted any proposal, then they'll have sent their values to the Proposer, who now must set the value of its proposal to the value associated with the highest proposal number reported by the Acceptors. If none of the Acceptors had accepted a proposal up to this point, then the Proposer may choose any value for its proposal.

**Phase 2b: Accepted**

? acceptor 之间如何相互学习？靠 leader 重发么

If an Acceptor receives an Accept Request message for a proposal N, it must accept it if and only if it has not already promised to any prepare proposals having an identifier greater than N. In this case, it should register the corresponding value v and send an Accepted message to the Proposer and every Learner. Else, it can ignore the Accept Request.

只要接受了 request, 也就默认认可了 leadership of the proposer. 

流程图

Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  |
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(1)
   |         |<---------X--X--X       |  |  Promise(1,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(1,Vn)
   |         |<---------X--X--X------>|->|  Accepted(1,Vn)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |


从此图可以看出，learner 是回复 client 的进程，而不是 proposer, 这就很奇怪了，为什么 client 请求的是 proposer, 而作为回复的却是 learner

几种失败场景:

1. Failure of acceptor, 少数派 acceptor 的失败，不会影响整个系统的可用性
2. Failure of redundant learner, 所有的 learner 都会通知
3. Failure of proposer(leader), 重新选举新的 leader, 假如 acceptors 接受过 accepted, 那么新的 leader 会学习到这个知识
4. dueling Proposers. 两个 proposer 会连续的推选自己 Prepare, 希望得到 acceptor 的认可，这个时候，就会发生活锁问题，这就要求
   proposer 要学会承认别人是 leader 这一事实

有一点不确定，leader 会不会学习到 accepted 这个知识呢？按照代码的说法，好像是可以的，但是没有被 accepted 的值是不应该被阻止的


Client   Proposer        Acceptor     Learner
   |      |             |  |  |       |  |
   X----->|             |  |  |       |  |  Request
   |      X------------>|->|->|       |  |  Prepare(1)
   |      |<------------X--X--X       |  |  Promise(1,{null,null,null})
   |      !             |  |  |       |  |  !! LEADER FAILS
   |         |          |  |  |       |  |  !! NEW LEADER (knows last number was 1)
   |         X--------->|->|->|       |  |  Prepare(2)
   |         |<---------X--X--X       |  |  Promise(2,{null,null,null})
   |      |  |          |  |  |       |  |  !! OLD LEADER recovers
   |      |  |          |  |  |       |  |  !! OLD LEADER tries 2, denied
   |      X------------>|->|->|       |  |  Prepare(2)
   |      |<------------X--X--X       |  |  Nack(2)
   |      |  |          |  |  |       |  |  !! OLD LEADER tries 3
   |      X------------>|->|->|       |  |  Prepare(3)
   |      |<------------X--X--X       |  |  Promise(3,{null,null,null})
   |      |  |          |  |  |       |  |  !! NEW LEADER proposes, denied
   |      |  X--------->|->|->|       |  |  Accept!(2,Va)
   |      |  |<---------X--X--X       |  |  Nack(3)
   |      |  |          |  |  |       |  |  !! NEW LEADER tries 4
   |      |  X--------->|->|->|       |  |  Prepare(4)
   |      |  |<---------X--X--X       |  |  Promise(4,{null,null,null})
   |      |  |          |  |  |       |  |  !! OLD LEADER proposes, denied
   |      X------------>|->|->|       |  |  Accept!(3,Vb)
   |      |<------------X--X--X       |  |  Nack(4)
   |      |  |          |  |  |       |  |  ... and so on ...

## Multi-paxos

If leader is relatively stable, the phase 1 becomes unnecessary. Thus, it is possible to skip future instances of 
the protocol with the same leader. 

To achieve this, the instance number I is included along with each value. Multi-Paxos reduces the failure-free message delay (proposal to learning)from 4 delays to 2 delays.

**Message flow: Multi-Paxos, start**

Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  | --- First Request ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(N)
   |         |<---------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(N,I,Vm)
   |         |<---------X--X--X------>|->|  Accepted(N,I,Vm)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |

Vm = highest of (Va, Vb, Vc)

在第一阶段确定了 Proposal Number 以后，后续就不用再做 Prepare 操作了。此外，I 表示 index 或者 sequence number

**Message flow: Multi-Paxos, steady-state**

Client   Proposer       Acceptor     Learner
   |         |          |  |  |       |  |  --- Following Requests ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Accept!(N,I+1,W)
   |         |<---------X--X--X------>|->|  Accepted(N,I+1,W)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |

## Paxos made moderately complex

自己读过的，最容易理解的代码

在此论文中，没有了 Proposer 和 Learner, 主要是得角色变成了 Leader, Acceptor, Replica, 其中 Replica 替代了 Learner，并承接了 Proposer 的部分功能。Client 的请求直接发送给 Replica, Replica 接收到请求后会转而发给 Leader。

文章带有一个[网站](http://paxos.systems/glossary.html)，详细描述了 paxos 和他们的算法

首先，关于 paxos 涉及到的一些内容

**Consensus:** In consensus problem, each process propose some initial value, and processes that do not fail must reach an irrevocable decision on exactly one of the proposed values. In Paxos, the replicas need to agree on the next state transition they handle, so that they remain in identical state. Paxos solve the consensus problem in asynchronous environment, where each process can crash.  But still, Paxos limited by the FLP impossiblility result in its ability to reach consensus in an asynchronous environment where process can crash.

**Consistency:** Distributed system replicate shared data to improve fault tolerance, data availability and performance. However, if the updates to this state is not carefully controlled, the state on different state might converge over time, creating inconsistency between replicas. In this case, two clients that read the state from two different replicas might see two different states. Different consistency model offers different consistency guarantee, but as long as the the user follows the rules associate with a consistency level, the distributed system guarantee that the user will not observer any inconsistencies. The most intuitive type of consistency is strong consistency. A protocol supports strong consistency, if all state changes are seen by all distributed processes in same order, sequentially. Paxos support this strong consistency.

**FLP Impossibility Result:** Consensus problem is not solvable in an asynchronous system.  The result states that there exists no deterministic algorithm that solves consensus in a asynchronous environment with reliable channels if one single process will crash. This is due to the fact that it is impossible to detect if 

A replicate state machine works by having multiple state machines, also called replicas, working in parallel, maintaining same state. When the replica receive requests from client they update their state by executing the command in the request and reply to the client. This way, the state is automatically replicated by the replicas and in the event of a failure the state does not get lost, make the state machine reliable. 
 
It is easy for the replica to execute client commands in the same order and remain in sync if there is only one client or if multiple clients send their requests strictly sequential. 
 
In this example replicas receive requests from clients in the same order, execute the commands in the same order and respond to the clients. in effect staying in sync. For simplicity, it is assumed that a client can ignore duplicated messages. 

But if multiple clients send requests to replicas in parallel, the different replica might receive there requests in different orders and execute the command in different orders, causing their local states to diverge from one another over time. 

To prevent replicas from diverging in the presence of multiple clients sending requests in parallel, the order in which the client commands will be executed by replicas should be decided. 

所以，问题的重点是，当很多消息同时到达时，paxos 需要保证 RSM 中的 command 在各个节点都是一致的，这就意味着有些消息会被暂时抛掉，有些消息接受的时间较早，但是会被安排后靠后的位置上执行。 下面看看 paxos 的如何转化这个问题的:

To decide the order which the clients commands will be executed the replicas can be thought of as having a **sequence of slots** that need to be filled with commands that make up the inputs to the state machine they maintain. Each slot is indexed by a slot number, starting from 1. Replicas receive requests from clients and assign them to specific slots, create a sequence of commands. In the face of concurrently operating clients, different replicas may propose different commands for the same slot. To avoid cinconsistency, a consensus protocol chooses a single command from the proposals for every slot. In Paxos the subprotocol that implements consensus is called the multi-decree synod protocol, or just synod protocol for short. A replica awaits the decision before actually updating its senquence of commands in the table, executing the next command and computing a response to send back to the client that issues the request.

更具体些，上面的描述没有说到当发生冲突以后，两个请求只有一个会被 synod algorithm 确认，那么另一个请求 c2 占用的 slot 会被覆盖，那么 c2 怎么办呢？一般来讲，c2 不会因为自己的 slot 被占用或者与别的请求发生了冲突就被丢弃掉，实际上，他会被放到下一个可用的 slot 上，等待被下一轮 synod 算法选中。这个时候，有一个问题，加入 client 先后发出两个请求 c1, c2. c1 和 c2 能够保证在状态机上有序么？就我目前的理解，是无法保证的。假设 c1, c2 发送到了同一个 replica, 在 replica 上分别被分配了 s1, s2 两个 slot, 但是在 synod 算法中，c1 被其他的 replica 请求打败，没能成功加入到 state machine 中，这个时候 s1 对应的 slot 就是 c1' 了，持有 c1, c2 的 leader 在 c1 被击败后失去了 view, 然后他会继续获取 view, 执行 phase1, phase1 包括从 acceptor 中学习已经被 accepted 的值，从中 leader 会学到 s1 -> c1'，然后他会把 s1 -> c1 丢掉。leader 后续会被 s1 -> c1' 和 s2 -> c2 继续向 acceptor 中传递，这样 c1 的顺序就在 c2 后面了。replica 会记录那些发出的 proposal, 再没有收到 decision 时，会继续发射 proposal, 这其中就包括了 c1, 当然， c1 对应的 slot 就不再是 s1 或 s2 了，至少是 s3 起。

Essentially, the replicated state machine uses Paxos as an ordering entity which uses consensus to agree on which client command gets assigned to which slot. One has to make sure that the ordering entity itself is also reliable, that it can tolerate failures just like replicated state machine. To achieve reliability, Paxos is run by multiple specialized processes in a distributed fashion. 

How does paxos works

**Replica** very important role

1. maintain application state
2. receive requests from clients
3. asks leader to serialize the requests so all replicas see the same sequence
4. responds to clients

When a client want to execute a command cmd = <clientId, clientSeq, op>, it broadcast request message to all replicas and waits for <response, clientId, result> message from one of the replicas (all replicas will respond however) 

Replica Invariants 

R1: There are no two different commands decided for the same slot.

R2: All commands up to slot_out are in the set of decisions.

R3: slot_out cannot decrease

R4: A replica propose commands only for slots it knows the configuration for: slot_in < slot_out + WINDOW

Paxos support reconfiguration: a client can propose a special reconfiguration command, which is decided in a slot like any other command. However, if s is the index of the slot in which a new configuration is decided, it does not take effect until slot s + WINDOW. This allows up to WINDOW slots to have proposals pending --- the configuration of later slots may change. It is always possible to add new replicas --- this does not require a reconfiguration of the leaders or acceptors.

如果没有 windows 的话，一个 replica 可能会提交任意多的 request.

从代码中，可以看出几点

1. slot_in > slot_out, 因为 slot_out 是已经确认的 command, 而 slot_in 是下一个可用的 slot, 如果某个 replica 没有收到过消息，而只是被动的从 commander 线程中接受消息，那么 slot_in 可能会小于 slot_out, 但是当消息到来时，需要给 proposal 队列添加 slot_int -> command, 这个时候就会检查 slot_in 是否已经在 decision 里面了，如果是，就 +1
2. 如果 slot_in 超过了 WINDOW size, 说明此时不应该继续发送请求，但是并不是把请求丢了，而是暂时保存在 requests 队列中，以后再发送
3. decision 消息的处理函数难理解些。perform 函数要保证几件事，第一件事是 slot_out 需要