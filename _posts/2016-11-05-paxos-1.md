## Paxos

Paxos is a family of protocols for solving consensus in a network of unreliable processors. 
Consensus is the process of agreeing on one result among a group of participants. 
This problem becomes difficult when the participants or their communication medium may experience failures.

###  假设

1. Processors operate at arbitrary speed
2. Processors may experience failure
3. Processors with stable storage may re-join the protocol after failure
4. Procesors do not collude, lie, or otherwise attempt to subvert the protocol.

1. Processors can send messages to another processor
2. Messages are sent asynchronously and may take arbitrarily long to deliver
3. Messages may be lost, reordered, or duplicated.
4. Messages are delivered without corruption.

简单来说，就是消息可能丢失，乱序，重复，延迟。进程可能会 crash, 延迟，或者 crash 之后重新加入到集群中。

### Roles

Acceptor(Voters):

The acceptor act as the fault-tolerant memory of the protocol. Acceptors are collected into groups called quorums. Any message sent to an acceptor must be sent to a quorum of acceptors.

Learner:

Learner act as the replication factor for the protocol. Once a client request has been agreed on by the acceptors, the learner may take action(execute the request and send a response to the client). To improve availability of processing, additional learner can be added.

Proposer:

A proposer advocates a client request, attempting to convince the acceptors to aggree on it, and acting as a coordinator to move the protocol forward when conflicts occur.

Paxos requires a distinguished proposer(called leader) to make progress. Many processes may believe they are leaders, but the protocol guarantees progress if one of them is eventually chosen. If two processes believe they are leaders, they may stall the protocol by continuously proposing conflicting updates. However, the safety properties are still preserved in that case.

Proposal number & aggreed value:

@todo

Non-trivality: only proposed values can be learned.

Safety: two different learners cannot learn different values.



## Basic Paxos

Each instance of basic paxos protocol on a single output value. The protocol proceeds over several rounds. A successfull round has two phase. A propose should not initate Paxos if it cannot communicate with at least a quorum of acceptors:

**Phase 1a: Prepare**

A proposer creates a proposal identified with a number N. This number must be greater than any previous proposal number used by this Proposer. Then it sends a Prepare message containing this proposal to Quorum of acceptors. The proposer decides who is in the Quorum.

从后面 multi-paxos 角度看 basic paxos, proposer number 变成了 sequence number


**Phase 1b: Promise**

If the proposal's number N is higher than any previous number received from any proposer by the acceptor, then the acceptor must return a promise to ignore all future proposals having a number less than N. If the acceptor accepted a proposal at some point in the past, it must include the previous proposal number and previous value in its response to the proposal.

otherwise, the acceptor can ignore the received proposal. It does not have to answer in this case for paxos to work. However, for the sake of optimization, sending a denial reponse would tell the proposal that it can stop its attempt to create consensus with proposal N.

**Phase 2a: Accept request**

If a Proposer receives enough promises from a Quorum of Acceptors, it needs to set a value to its proposal. If any Acceptors had previously accepted any proposal, then they'll have sent their values to the Proposer, who now must set the value of its proposal to the value associated with the highest proposal number reported by the Acceptors. If none of the Acceptors had accepted a proposal up to this point, then the Proposer may choose any value for its proposal.

**Phase 2b: Accepted**

? acceptor 之间如何相互学习？靠 leader 重发么

If an Acceptor receives an Accept Request message for a proposal N, it must accept it if and only if it has not already promised to any prepare proposals having an identifier greater than N. In this case, it should register the corresponding value v and send an Accepted message to the Proposer and every Learner. Else, it can ignore the Accept Request.

只要接受了 request, 也就默认认可了 leadership of the proposer. 

流程图

Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  |
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(1)
   |         |<---------X--X--X       |  |  Promise(1,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(1,Vn)
   |         |<---------X--X--X------>|->|  Accepted(1,Vn)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |


从此图可以看出，learner 是回复 client 的进程，而不是 proposer, 这就很奇怪了，为什么 client 请求的是 proposer, 而作为回复的却是 learner

几种失败场景:

1. Failure of acceptor, 少数派 acceptor 的失败，不会影响整个系统的可用性
2. Failure of redundant learner, 所有的 learner 都会通知
3. Failure of proposer(leader), 重新选举新的 leader, 假如 acceptors 接受过 accepted, 那么新的 leader 会学习到这个知识
4. dueling Proposers. 两个 proposer 会连续的推选自己 Prepare, 希望得到 acceptor 的认可，这个时候，就会发生活锁问题，这就要求
   proposer 要学会承认别人是 leader 这一事实

有一点不确定，leader 会不会学习到 accepted 这个知识呢？按照代码的说法，好像是可以的，但是没有被 accepted 的值是不应该被阻止的


Client   Proposer        Acceptor     Learner
   |      |             |  |  |       |  |
   X----->|             |  |  |       |  |  Request
   |      X------------>|->|->|       |  |  Prepare(1)
   |      |<------------X--X--X       |  |  Promise(1,{null,null,null})
   |      !             |  |  |       |  |  !! LEADER FAILS
   |         |          |  |  |       |  |  !! NEW LEADER (knows last number was 1)
   |         X--------->|->|->|       |  |  Prepare(2)
   |         |<---------X--X--X       |  |  Promise(2,{null,null,null})
   |      |  |          |  |  |       |  |  !! OLD LEADER recovers
   |      |  |          |  |  |       |  |  !! OLD LEADER tries 2, denied
   |      X------------>|->|->|       |  |  Prepare(2)
   |      |<------------X--X--X       |  |  Nack(2)
   |      |  |          |  |  |       |  |  !! OLD LEADER tries 3
   |      X------------>|->|->|       |  |  Prepare(3)
   |      |<------------X--X--X       |  |  Promise(3,{null,null,null})
   |      |  |          |  |  |       |  |  !! NEW LEADER proposes, denied
   |      |  X--------->|->|->|       |  |  Accept!(2,Va)
   |      |  |<---------X--X--X       |  |  Nack(3)
   |      |  |          |  |  |       |  |  !! NEW LEADER tries 4
   |      |  X--------->|->|->|       |  |  Prepare(4)
   |      |  |<---------X--X--X       |  |  Promise(4,{null,null,null})
   |      |  |          |  |  |       |  |  !! OLD LEADER proposes, denied
   |      X------------>|->|->|       |  |  Accept!(3,Vb)
   |      |<------------X--X--X       |  |  Nack(4)
   |      |  |          |  |  |       |  |  ... and so on ...

## Multi-paxos

If leader is relatively stable, the phase 1 becomes unnecessary. Thus, it is possible to skip future instances of 
the protocol with the same leader. 

To achieve this, the instance number I is included along with each value. Multi-Paxos reduces the failure-free message delay (proposal to learning)from 4 delays to 2 delays.

**Message flow: Multi-Paxos, start**

Client   Proposer      Acceptor     Learner
   |         |          |  |  |       |  | --- First Request ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Prepare(N)
   |         |<---------X--X--X       |  |  Promise(N,I,{Va,Vb,Vc})
   |         X--------->|->|->|       |  |  Accept!(N,I,Vm)
   |         |<---------X--X--X------>|->|  Accepted(N,I,Vm)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |

Vm = highest of (Va, Vb, Vc)

在第一阶段确定了 Proposal Number 以后，后续就不用再做 Prepare 操作了。此外，I 表示 index 或者 sequence number

**Message flow: Multi-Paxos, steady-state**

Client   Proposer       Acceptor     Learner
   |         |          |  |  |       |  |  --- Following Requests ---
   X-------->|          |  |  |       |  |  Request
   |         X--------->|->|->|       |  |  Accept!(N,I+1,W)
   |         |<---------X--X--X------>|->|  Accepted(N,I+1,W)
   |<---------------------------------X--X  Response
   |         |          |  |  |       |  |

## Paxos made moderately complex

自己读过的，最容易理解的代码

在此论文中，没有了 Proposer 和 Learner, 主要是得角色变成了 Leader, Acceptor, Replica, 其中 Replica 替代了 Learner，并承接了 Proposer 的部分功能。Client 的请求直接发送给 Replica, Replica 接收到请求后会转而发给 Leader。


