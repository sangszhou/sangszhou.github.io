## 蓄水池抽样算法

要求从N个元素中随机的抽取k个元素，其中N无法确定。

主要思想就是保持一个集合（这个集合中的每个数字出现），作为蓄水池，依次遍历所有数据的时候以一定概率替换这个蓄水池中的数字。

```java
Init : a reservoir with the size： k  
    for    i= k+1 to N  
        M = random(1, i);  
        if(M < k)  
            SWAP the Mth value and ith value  
    end for 
```

程序的开始就是把前k个元素都放到水库中，然后对之后的第i个元素，以k/i的概率替换掉这个水库中的某一个元素

下面来具体证明一下：每个水库中的元素出现概率都是相等的:

(1) 初始情况。出现在水库中的k个元素的出现概率都是一致的，都是1。这个很显然。

(2) 第一步。第一步就是指，处理第k+1个元素的情况。分两种情况：1. 元素全部都没有被替换 2. 其中某个元素被第k+1个元素替换掉

我们先看情况2：第k+1个元素被选中的概率是k/(k+1) (当 m < k 时才能被替换), 水库中任意一个元素被替换掉的概率是：(k/k+1)*(1/k)=1/(k+1),
意即首先要第 k+1 个元素被选中，然后自己在集合的 k 个元素中被选中, 那它不被替换的概率就是1-1/(k+1)=k/(k+1)。
可以看出来，旧元素和新元素出现的概率是相等的。

情况1：当元素全部都没有替换掉的时候，每个元素的出现概率肯定是一样的，这很显然。但具体是多少呢？就是1-P(第k+1个元素被选中)=1-k/(k+1)=1/(k+1)。

归纳法：重复上面的过程，只要证明第i步到第i+1步，所有元素出现的概率是相等的即可

**Solution:** 以1/i的概率取第i个元素

证明：数学归纳法。当i=1时：第1个元素以1/1=1的概率被取，符合条件。

设 i=k 时符合条件，即前k个元素都以1/k的概率被取。

则i=k+1时：对于第k+1个元素，被取概率为1/（k+1），符合条件。

对于前k个元素，每个元素被取的概率=被取并且没被第k+1个元素替换的概率=（1/k）*(1−1/（k+1）)=1/（k+1）符合条件。

综上所述：得证。

## 后缀数组求最长重复子串

给定一个字符串，求出其最长重复子串

例如：abcdabcd

最长重复子串是 abcd，最长重复子串可以重叠

例如：abcdabcda，这时最长重复子串是 abcda，中间的 a 是被重叠的

直观的解法是，首先检测长度为 n - 1 的字符串情况，如果不存在重复则检测 n - 2, 一直递减下去，直到 1 。
这种方法的时间复杂度是 O(N * N * N)，其中包括三部分，长度纬度、根据长度检测的字符串数目、字符串检测

改进的方法是利用**后缀数组**

后缀数组是一种数据结构，对一个字符串生成相应的后缀数组后，然后再排序，排完序依次检测相邻的两个字符串的开头公共部分。

这样的时间复杂度为：生成后缀数组 O(N)，排序 O(NlogN*N)  最后面的 N 是因为字符串比较也是 O(N)
依次检测相邻的两个字符串 O(N * N)，总的时间复杂度是 O(N^2*logN)，优于第一种方法的 O(N^3)

对于类似从给定的文本中，查找其中最长的重复子字符串的问题，可以采用“后缀数组”来高效地完成此任务。后缀数组使用文本本身和n个附加指针（与文本数组相应的指针数组）来表示输入文本中的n个字符的每个子字符串。

## Trie树详解及其应用

[link](http://blog.csdn.net/hackbuteer1/article/details/7964147)

字典树（Trie）可以保存一些字符串->值的对应关系。基本上，它跟 Java 的 HashMap 功能相同，都是 key-value 映射，只不过 Trie 的 key 只能是字符串

Trie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关。Hash 表号称是 O(1) 的，但在计算 hash 的时候就肯定会是 O(k) ，而且还有碰撞之类的问题；Trie 的缺点是空间消耗很高。

至于Trie树的实现，可以用数组，也可以用指针动态分配，我做题时为了方便就用了数组，静态分配空间。

Trie树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

Trie 的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

Trie树的基本性质可以归纳为： 

1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 
3. 每个节点的所有子节点包含的字符串不相同。

Trie树有一些特性:

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。
4. 如果字符的种数为n，则每个结点的出度为n，这也是空间换时间的体现，浪费了很多的空间。
5. 插入查找的复杂度为O(n)，n为字符串长度。

基本思想(以字母树为例):

1. 插入过程

对于一个单词，从根开始，沿着单词的各个字母所对应的树中的节点分支向下走，直到单词遍历完，将最后的节点标记为红色，表示该单词已插入Trie树。

2. 查询过程

同样的，从根开始按照单词的字母顺序向下遍历trie树，一旦发现某个节点标记不存在或者单词遍历完成而最后的节点未标记为红色，则表示该单词不存在，若最后的节点标记为红色，表示该单词存在。

### 二、字典树的数据结构：

下面以英文单词构建的字典树为例，这棵Trie树中每个结点包括26个孩子结点，因为总共有26个英文字母(假设单词都是小写字母组成)。

```c
typedef struct Trie_node {
	int count;                    // 统计单词前缀出现的次数
	struct Trie_node* next[26];   // 指向各个子树的指针
	bool exist;                   // 标记该结点处是否构成单词  
} TrieNode , *Trie;
```

其中next是一个指针数组，存放着指向各个孩子结点的指针。

应用:

已知n个由小写字母构成的平均长度为10的单词，判断其中是否存在某个串为另一个串的前缀子串。下面对比3种方法：

1. 最容易想到的：即从字符串集中从头往后搜，看每个字符串是否为字符串集中某个字符串的前缀，复杂度为O(n^2)。

2. 使用hash：我们用hash存下所有字符串的所有的前缀子串。建立存有子串hash的复杂度为O(n*len)。查询的复杂度为O(n)* O(1)= O(n)。

3. 使用Trie：因为当查询如字符串abc是否为某个字符串的前缀时，显然以b、c、d....等不是以a开头的字符串就不用查找了，
   这样迅速缩小查找的范围和提高查找的针对性。所以建立Trie的复杂度为O(n*len)，而建立+查询在trie中是可以同时执行的，
   建立的过程也就可以成为查询的过程，hash就不能实现这个功能。所以总的复杂度为O(n*len)，实际查询的复杂度只是O(len)。
   

### 三、Trie树的操作

在Trie树中主要有3个操作，插入、查找和删除。一般情况下Trie树中很少存在删除单独某个结点的情况，因此只考虑删除整棵树。

1、插入


## Functional Queue

```scala
class Queue[T](
    private val leading: List[T],
    private val trailing: List[T]) {
    
    private def mirror =
        if (leading.isEmpty) new Queue(trailing.reverse, Nil)
        else this
    
    def head = mirror.leading.head
    
    def tail = {
        val q = mirror
        new Queue(q.leading.tail, q.trailing)
    }
    
    def enqueue(x: T) = new Queue(leading, x :: trailing)
}
```

## 剑指 offer

[link](http://blog.jobbole.com/70599/)

1:合并排序，将两个已经排序的数组合并成一个数组，其中一个数组能容下两个数组的所有元素

2:合并两个单链表

3:倒序打印一个单链表

4:给定一个单链表的头指针和一个指定节点的指针，在O(1)时间删除该节点

5:找到链表倒数第K个节点

6:反转单链表

7:通过两个栈实现一个队列

8:二分查找

9:快速排序

10:获得一个 int 型的数中二进制中的个数

11:输入一个数组，实现一个函数，让所有奇数都在偶数前面

12:判断一个字符串是否是另一个字符串的子串

13:把一个int型数组中的数字拼成一个串，这个串代表的数字最小

14:输入一颗二叉树，输出它的镜像（每个节点的左右子节点交换位置）

15:输入两个链表，找到它们第一个公共节点

