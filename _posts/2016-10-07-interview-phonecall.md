---
layout: post
title: phone interview
categories: [interview]
keywords: interview
---
### 进程如何通信

共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

管道

### 软连接硬链接

[link](http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html)

Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接。

硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。

另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。



### 1. 覆盖和重载的区别是什么

覆盖在运行时决定, 重载是在编译时决定。并且重载和覆盖的机制不同, 例如在 java 中, 重载方法的签名必须不同于
原先方法, 但对于覆盖签名必须相同。

此处可以继续扩展

### 2. fork 一个进程和一个线程的有什么区别

当你 fork 一个进程时, 新的进程将执行和父进程相同的代码, 只是在不同的内存空间。 但当你在已有的进程中
生成一个线程时, 它会生成一个新的代码执行路线, 但共享同一个空间。

一个进程可以有多个线程, 但是一个线程总属于一个进程。两个进行不能共享内存空间, 除非阿门有意通过共享内存来通信, 但是同一个
进程的所有线程总是共享相同的内存。

### 3. 什么是临界区

临界区是一段代码, 在多线程环境下, 同一个时间只能被一个线程执行。可以通过信号量和互斥量来保护临界区,
在 java 中可以使用 synchronized 和 ReentrantLock 来保护临界区。

### 4. 值类型和引用类型有什么区别

值类型是更加优化的类型, 总是不可变的, 例如 java 原始的 int, long, double 和 float. 引用类型指向一个对象,
可能是可变的, 也可能是不可变的。值类型指向一个值, 引用类型指向一个对象。

### 5. 什么是进程中的堆和栈

在同一个线程中, 有两块不同的内存区域。以 java 来说, 栈用来存储原始值和指向对象的引用类型, 但对象本身总是在堆中
被创建。堆和栈的重要区别是, 堆内存被所有的线程共享, 但是每个线程有自己的栈。

### 6. 什么是版本控制

版本控制是用来存储和管理代码的。它的主要作用是代码审查, 代码对比, 维护稳定的版本的

### 7. 什么是强类型设计语言

在强类型语言中, 编译器保证类型的正确性, 例如无法在 String 类型中存放数字。Java 是强类型语言, 但 python 等是
弱类型语言, 弱类型语言在编译时不会进行类型检查, 在运行时刻检查

### 8. immutable 类是什么意思

一个类在创建以后他的状态就不可变, 那么他就是不可变的。比如 java 的 string, 不可变对象在并行程序设计中是很有用的,
因为他们可以在进程间被共享, 不需要担心同步问题。

### 9. 什么是 SQL 注入

任何从用户那里得到的输入并不加验证的执行 SQL 语句都可能被 SQL 注入攻击。在这样的系统中, 入侵者可以输入 SQL 代码, 而不是数据
来获取额外的数据。在 java 中可以使用 prepared 语句来避免 SQL 注入。

### 10. SQL 中, 内连接和左连接有什么区别

在 SQL 中, 主要由两种连接类型, 内连接和外连接。外连接包括右外连接和左外连接。内连接和左连接的区别
在于: 内连接中两个表匹配的记录才会被选中, 左连接中两个表匹配的记录会被选中, 外加左表的所有记录都会
被选中。

### 11. MVC 中的 V 代码什么, 意味着什么

V 是视图。视图是用户看到的东西, 包括网页。模型是实际的业务对象, 比如用户, 雇员, 订单, 控制器用来将请求发送给正确的处理单元。

### 12. 什么是松耦合 (loose-couping)

松耦合是一种软件特性, 它使得软件一部分的修改不会对其他部分造成影响。

### 13. 组合 (composition), 聚合 (aggregation), 关联 (association) 的区别是什么

关联是指两个对象相互联系。组合是关联的一种形式, 级一个对象由多个对象组成, 但是他们是共存的, 例如人体是有多个器官组成的,
独立的器官不能单独存在, 他们必须在身体内发挥作用。聚合也是关联的一种, 表示对象的集合, 比如城市是居民的集合。

### 14. 接口和抽象类的区别

接口是最纯粹的抽象形式, 没有任何具体的东西。抽象类是一些抽象事物和具体事物的组合体。比如在 java 中可以扩展一个抽象类,
但是只能继承一个抽象类。

在interface里面的变量都是`public static final` 的。所以你可以这样写：

```java
public static final int i=10;

int i=10;
```

注意在声明的时候要给变量赋予初值

**解释：**

首先你要弄清接口的含义.接口就是提供一种统一的’协议’,而接口中的属性也属于’协议’中的成员.它们是公共的,静态的,最终的常量.相当于全局常量.
抽象类是不’完全’的类,相当于是接口和具体类的一个中间层.即满足接口的抽象,也满足具体的实现.

如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，
可以通过实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口A中有一个public访问权限的静态变量a。
按照Java的语义，我们可以不通过实现接口的对象来访问变量a，通过A.a = xxx;就可以改变接口中的变量a的值了。正如抽象类中是可以这样做的，
那么实现接口A的所有对象也都会自动拥有这一改变后的a的值了，也就是说一个地方改变了a，所有这些对象中a的值也都跟着变了。这和抽象类有什么区别呢，
怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中不能出现变量，如果有变量，
就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统一的属性。

通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，
对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。


### 15. 什么是单元测试和集成测试

单元测试是测试独立单元(而不是整个应用程序) 功能性的一种方法。单元测试经常在构建时自动运行, 或者在一个持续的环境中进行。

集成测试已被测试过的独立单元是否能够共同工作。

### 17. 什么是测试驱动开发

测试驱动开发是一个常用的开发方式。在这种开发方式中, 测试代码在功能代码之前编写。这样能够提高代码质量。

### 18. 哈希表处理冲突有哪些办法

线性探测, 二次哈希和链接。在线性探测中, 如果桶被占据了, 那么函数会线性的检查下一个桶, 直到找到空位。在链接中, 多个哈希元素
可以保存在一个桶中, 这个桶往往是个链表。

### 19. 不能使用运算符, 怎么判断是个数是不是 2 的幂

n&(n-1)

### 20. ps 命令

ps -ef e 表示列出所有的进程, f 表示显示所有细节, 包括 PID

### 21. 如果在 Linux 中查找大的文件 比如大于 1G 的

find . -type f -szie +1G -print

###

### 个人项目面试题, 包括 HBase, Kafka, TCP 长连接问题

http://blog.csdn.net/lisonglisonglisong/article/details/51327589

上面还有各种面试题

http://blog.csdn.net/lisonglisonglisong/article/details/51327589

### Kafka 问题

就问你一个基本的streaming service怎么implement
数据怎么存，怎么读写。在拓展看来分布式情况下怎么handle traffic fault
tolerate bla blahh
言之有理就行


### TIME_WAIT 状态的产生、危害、如何避免？

TCP协议在关闭连接的四次挥手中，为了应对最后一个 ACK 丢失的情况，Client（即主动关闭连接的一方）需要维持 time_wait 状态并停留 2 个 MSL 的时间

危害：Linux分配给一个用户的文件句柄是有限的，如果系统中存在大量的 time_wait 状态，一旦达到句柄数上限，新的请求就无法被处理了，
而且大量 time_wait 连接占用资源影响性能。

如何避免：在/etc/sysctl.conf文件中开启 net.ipv4.tcp_tw_reuse 重用和 net.ipv4.tcp_tw_recycle 快速回收

### 5、守护、僵尸、孤儿进程的概念

1. 守护进程：运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务。
2. 僵尸进程：一个进程 fork 子进程，子进程退出，而父进程没有 wait/waitpid子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。
3. 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

### linux下你常用的命令有哪些

【答】ll、pwd、touch、rm、mkdir、rmdir、mv、cp、ln
cat、less、more、tail、vim、vimdiff、grep
tar、rz、sz
df、du、free、top、ethtool、sar、netstat、iostat、ps
ifconfig、ping、talnet

### TCP建立连接为什么需要三次？断开连接又为什么需要四次

“三次握手”的主要目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

### 5、数据库索引的优缺点？

优点：提高数据检索的性能。
缺点：

1. 索引会占据物理存储空间
2. 当向表中添加/删除数据时，索引也需动态更新，降低了插入/删除的速度

### 6、数据库的三范式？

1. 1NF：字段不可分（原子性）
2. 2NF：有主键，非主键字段依赖主键（唯一性）
3. 3NF：非主键字段不能相互依赖（每列都与主键有直接关系，不存在传递依赖）

### 7、如何在一个不安全的环境中实现安全的数据通信？

要实现数据的安全传输，当然就要对数据进行加密了。

如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，
就存在密码泄漏的可能。所以我们使用非对称算法，过程如下：

* 首先 接收方 生成一对密钥，即私钥和公钥；
* 然后，接收方 将公钥发送给 发送方；
* 发送方用收到的公钥对数据加密，再发送给接收方；
* 接收方收到数据后，使用自己的私钥解密。

由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。

非对称算法的计算时间会耗费的比较长

### 3、阻塞IO、非阻塞IO、同步IO、异步IO的区别？

阻塞IO（blocking IO）：线程阻塞以等待数据，然后将数据从内核拷贝到进程，返回结果之后才解除阻塞状态。也就是说两个阶段都被block了。

非阻塞IO（non-blocking IO）：当对一个非阻塞socket执行读操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。用户进程需要不断地主动进行read操作，一旦数据准备好了，就会把数据拷贝到用户内存。也就是说，第一阶段并不会阻塞线程，但第二阶段拷贝数据还是会阻塞线程。

IO复用（IO multiplexing）：这种IO方式也称为event driven IO. 通过使用select/poll/epoll在单个进程中同时处理多个网络连接的IO。例如，当用户进程调用了select，那么整个进程会被block，通过不断地轮询所负责的所有socket，当某个socket的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。在IO复用模型中，实际上对于每一个socket，一般都设置成为non-blocking，但是，整个用户进程其实是一直被block的，先是被select函数block，再是被socket IO第二阶段block。

同步IO（synchronous IO）：POSIX中的同步IO定义是—— A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes。也就是说同步IO在IO操作完成之前会阻塞线程，按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。（non-blocking IO也属于同步IO是因为它在真正拷贝数据时也会阻塞线程）

异步IO（asynchronous IO）：POSIX中的异步IO定义是—— An asynchronous I/O operation does not cause the requesting process to be blocked。在linux异步IO中，用户进程发起read操作之后，直接返回，去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。也就是说两个阶段都不会阻塞线程。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。

### 简述一下ping的原理

简单地说，ping就是给目标IP地址发送一个 ICMP 回显请求，并要求对方返回一个 ICMP 回显应答来确定两台网络机器是否连通，时延是多少。

在 ICMP 逐层封装的过程中，需要知道源IP、源MAC地址、目的IP、目的MAC地址，前三者是已知的，只需要获取目的MAC地址即可：

若在同一网段，只需要发送ARP广播；

若不在同一网段，发送ARP广播给交换机，交换机若没有缓存目的IP对应的MAC地址，它会再转发该ARP广播包。

### 4、什么是事务？事务有哪些特性？

【解】事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。

1. 原子性：要么完全执行，要么完全不执行
2. 一致性：事务完成时，所有数据保持一致
3. 隔离性：多个事务作修改时，互相隔离
4. 持久性：事务所作的修改是永久性的

### 5、MySQL的引擎 InnoDB 和 MyISAM 的区别。

1. InnoDB支持外键，MyISAM不支持；
2. InnoDB支持事务处理，MyISAM不支持；
3. InnoDB是行锁，MyISAM是表锁；
4. MyISAM是默认的存储引擎，强调性能。

### 心跳包和 TCP keep alive 的区别

首先，对于网络通信我们选择使用TCP长连接，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。
优点：

1. 简单有效的长连接
2. 可靠的信息传输
3. 数据包的大小没有限制
4. 服务器可以主动向客户端推送消息（广播等）

客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。

TCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？

TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；

keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；

keep-alive不能主动通知应用层；

另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；

### log level

```
Fatal	Highest level: important stuff down
Error	For example application crashes / exceptions.
Warn	Incorrect behavior but the application can continue
Info	Normal behavior like mail sent, user updated profile etc.
Debug	Executed queries, user authenticated, session expired
Trace	Begin method X, end method X etc
```
