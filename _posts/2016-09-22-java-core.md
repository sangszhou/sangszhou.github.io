### Object

```java
clone
    throws CloneNotSupportedException

equals(object): boolean
    return (this == obj);

finalize
getClass: Class<?>
hashCode: int
notify
notifyAll
wait

wait(long)  // milli second
    throws InterruptedException

wait(long, int) // nano second

toString
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
```

== 的约束要比 equals 要强, equals 往往需要检测内容是否真的匹配

concurrent hashmap 中的比对方式。check hash 是因为怕 hash 发生了变化
```java
if((k = e.key) == key || e.hash == hash && key.equals(key))
```

### String

```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i]; // 31 等于向左移动 6 个字节
        }
        hash = h;
    }
    return h;
    }
```

```java
String implements java.io.Serializable, Comparable<String>, CharSequence
    private final char value[];
    private int hash; // Default to 0
    private static final long serialVersionUID = -6849794470754667710L;
```

**why 31?**

1. The value 31 was chosen because it is an odd prime
2. better performance: 31 * i == (i << 5) - i. Modern VMs do this sort of optimization automatically

**Why is String immutable in Java?**

When we create a string in java like String s1="hello"; then an object will be created in string pool(hello) and 
s1 will be pointing to hello. Now if again we do String s2="hello"; then another object will not be 
created but s2 will point to hello because JVM will first check if the same object is present in 
string pool or not. If not present then only a new one is created else not.

Java Developers decide Strings are immutable due to the following aspect design, efficiency, and security.

**Efficiency** The hashcode of string is frequently used in Java. For example, 
in a HashMap. Being immutable guarantees that hashcode will always the same, so that it can be cached without 
worrying the changes.That means, there is no need to calculate hashcode every time it is used.

**Security** String is widely used as parameter for many java classes, e.g. network connection, 
opening files, etc. Were String not immutable, a connection or file would be changed and lead to serious security 
threat. Mutable strings could cause security problem in Reflection too, as the parameters are strings.

**Design** Strings are created in a special memory area in java heap known as "String Intern pool". While you creating new String
variable it searches the pool to check whether is it already exist. If it is exist, then return reference of the existing String object. 
If the String is not immutable, changing the String with one reference will lead to the wrong value for the other references.

```java
public static void main(String[] args) {
        String s1 = "Test";
        String s2 = "Test";
        String s3 = new String("Test");
        final String s4 = s3.intern(); // string constant pool
        
        System.out.println(s1 == s2); // true
        System.out.println(s2 == s3); // false
        System.out.println(s3 == s4); // false
        System.out.println(s1 == s3); // false
        System.out.println(s1 == s4); // true
        System.out.println(s1.equals(s2)); // true
        System.out.println(s2.equals(s3)); // true
        System.out.println(s3.equals(s4)); // true
        System.out.println(s1.equals(s4)); // true
        System.out.println(s1.equals(s3)); // true
    }
}
```


